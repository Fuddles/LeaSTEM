#!/usr/bin/env node

/**
 * Module dependencies.
 */
var debug = require('debug')('leastem:server');

/**
 *  From now on, does not allow the Node.js server to crash from an uncaught exception
 *
 *  uncaughtException should be used to perform synchronous cleanup before shutting down the process.
 *  It is not safe to resume normal operation after uncaughtException.
 *  If you do use it, restart your application after every unhandled exception!
 *  You have been warned.
 */
process.on('uncaughtException', function(err) {
   console.error('\n\nFATAL ERROR !!!! -- Caught exception: ' + err);
   try {
       //console.trace( "\nMore info (console.trace):" );
       console.error( "\n\nError Stack-trace:");
       console.error( err.stack );
   }
   catch (exc) {}
});


// ███    ███ ██    ██ ██   ████████ ██    ████████ ██   ██ ██████  ███████  █████  ██████
// ████  ████ ██    ██ ██      ██    ██       ██    ██   ██ ██   ██ ██      ██   ██ ██   ██
// ██ ████ ██ ██    ██ ██      ██    ██ █████ ██    ███████ ██████  █████   ███████ ██   ██
// ██  ██  ██ ██    ██ ██      ██    ██       ██    ██   ██ ██   ██ ██      ██   ██ ██   ██
// ██      ██  ██████  ███████ ██    ██       ██    ██   ██ ██   ██ ███████ ██   ██ ██████

const cluster = require('cluster');

// ----- Main process is LED-lighting, child process is web server, and we spawn also the sensor reading
if (cluster.isMaster) {

    const setCurrentPhotoPromise = require("../process/image-functions").setCurrentPhotoPromise;
    const initLoop = require("../process/do-loop").initLoop;

    // 1. --- Launch the angle reader (BNO055 sensor)
    const childProcSpawn = require('child_process').spawn;          // always use spawn rather than exec or execFile!
    const bno055Command  = "/bin/pwd"; // "/usr/bin/python";
    const bno055Args     = [];    // [ "./bin/python/read-bno055.py" ];

    debug("Launching BNO055 reading with:  %s %s", bno055Command, bno055Args);
    let angleSensorSpawn = childProcSpawn( bno055Command, bno055Args );      // ,{} for options
    angleSensorSpawn.on('error', (err) => {
        console.error( "ERROR in angleSensorSpawn: process FAILED with error:" );
        console.error( err );
        throw new Error(err);
    });
    angleSensorSpawn.on('exit', (code,signal) => {
        debug( "EXIT of angleSensorSpawn: process completed with code=%s and signal=%s", code, signal );
    });
    angleSensorSpawn.stdout.on( 'data', (data) => {
        debug("angleSensorSpawn: \t %s", data);

        // TODO: PARSE and STORE this data for angle and rotation speed
        //debug( data );
    });


    // 2. --- Connect the processes: current image + angle
    //        Note: to send a message from the child to the master, do:
    //                  process.send( { ... } );
    //              to send a message from the master to the child, do:
    //                  global.leaHttpWorker.send( { ... } );
    //        Messages from child (http-server) to master (led-lighting)
    cluster.on('message', (worker, msg) => {

        if ( ! msg || ! msg.action ) {
            console.error("ERROR in cluster on message: EMPTY msg");
            console.error( msg );
            return;
        }

        // process.send( { action: "currentPhoto", filename: resizedPhotoFilename } );
        if ( msg.action == "currentPhoto" ) {
            setCurrentPhotoPromise( msg.filename );
            return;
        }
    });


    // 3. --- Launch the web server
    cluster.fork();
    // If the worker ever dies while the master is still alive, log error!
    cluster.on('exit', (worker, code, signal) => {
        console.error('\nERROR! Worker ' + worker.process.pid + ' died with code: ' + code + ', and signal: ' + signal);
    });


    // 4. --- Start displaying LEDs
    //        We only start when Master receives a signal when the webser worker is online
    cluster.on('online', function(worker) {
        debug('Worker ' + worker.process.pid + ' is online');
        global.leaHttpWorker = worker;              // Also equals to cluster.workers[0]

        initLoop();
    });

}
else {

    // Messages from master (led-lighting) to child (http-server)
    process.on('message', msg => {

        if ( !msg || !msg.action ) {
            console.error("ERROR in webserver process on message: EMPTY msg");
            return;
        }

        // process.send( { action: "currentPhoto", filename: resizedPhotoFilename } );
        if ( msg.action == "currentPhoto" ) {
            debug("global.currentImageFileName on webserver thread set to %s", msg.filename);
            global.currentImageFileName = msg.filename;
            return;
        }
    });


    // ██     ██ ███████ ██████      ███████ ███████ ██████  ██    ██ ███████ ██████
    // ██     ██ ██      ██   ██     ██      ██      ██   ██ ██    ██ ██      ██   ██
    // ██  █  ██ █████   ██████      ███████ █████   ██████  ██    ██ █████   ██████
    // ██ ███ ██ ██      ██   ██          ██ ██      ██   ██  ██  ██  ██      ██   ██
    //  ███ ███  ███████ ██████      ███████ ███████ ██   ██   ████   ███████ ██   ██

    var http = require('http');
    var app  = require('../app');

    /**
    * Get port from environment and store in Express.
    */
    var port = normalizePort(process.env.PORT || '3000');
    app.set('port', port);

    /**
    * Create HTTP server.
    */
    var server = http.createServer(app);

    /**
    * Listen on provided port, on all network interfaces.
    */
    server.listen(port);
    server.on('error', onError);
    server.on('listening', onListening);

}





// +++++++++++++++++++++++++++ HELPERS +++++++++++++++++++++++++++++++++++++++++

/**
 * Normalize a port into a number, string, or false.
 */
function normalizePort(val) {
  var port = parseInt(val, 10);

  if (isNaN(port)) {
    // named pipe
    return val;
  }

  if (port >= 0) {
    // port number
    return port;
  }

  return false;
}


/**
 * Event listener for HTTP server "error" event.
 */
function onError(error) {
  if (error.syscall !== 'listen') {
    throw error;
  }

  var bind = typeof port === 'string'
    ? 'Pipe ' + port
    : 'Port ' + port;

  // handle specific listen errors with friendly messages
  switch (error.code) {
    case 'EACCES':
      console.error(bind + ' requires elevated privileges');
      process.exit(1);
      break;
    case 'EADDRINUSE':
      console.error(bind + ' is already in use');
      process.exit(1);
      break;
    default:
      throw error;
  }
}


/**
 * Event listener for HTTP server "listening" event.
 */
function onListening() {
  var addr = server.address();
  var bind = typeof addr === 'string'
    ? 'pipe ' + addr
    : 'port ' + addr.port;
  debug('Listening on ' + bind);
}
